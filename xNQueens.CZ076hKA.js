import{d as f,_ as v,c as o,b as p,F as m,h as b,o as a,n as g,t as u,a as c,w as k,v as y,m as z,q as $,s as w}from"./xindex.nwv0rKjI.js";const B=f({props:["board","highlight","selected"],data(){return{}},methods:{clickSquare(e){this.$emit("clickSquare",e)},getHighlight(e){const s={};return this.highlight&&this.highlight.forEach(t=>{t.x===e.x&&t.y===e.y&&(s.highlight=!0)}),this.selected&&this.selected.x===e.x&&this.selected.y===e.y&&(s.selected=!0),s}}}),S=["onClick"],T={key:0,class:"piece"},C={key:1,class:"piece"},Q={key:2,class:"piece"},N={key:3,class:"piece"},F={key:4,class:"piece"},I={key:5,class:"piece"},R={key:6,class:"piece"},V={key:7,class:"piece"},D={key:8,class:"piece"},E={key:9,class:"piece"},K={key:10,class:"piece"},L={key:11,class:"piece"},M={key:12},O={key:13,class:"piece"};function H(e,s,t,r,n,h){return a(),o("div",null,[p("table",null,[(a(!0),o(m,null,b(e.board,(i,d)=>(a(),o("tr",{key:d},[(a(!0),o(m,null,b(i,(l,_)=>(a(),o("td",{key:_,class:g(e.getHighlight({x:_,y:7-d})),onClick:J=>e.clickSquare({x:_,y:7-d})},[l==="K"?(a(),o("span",T,"♔")):l==="Q"?(a(),o("span",C,"♕")):l==="R"?(a(),o("span",Q,"♖")):l==="B"?(a(),o("span",N,"♗")):l==="N"?(a(),o("span",F,"♘")):l==="P"?(a(),o("span",I,"♙")):l==="k"?(a(),o("span",R,"♚")):l==="q"?(a(),o("span",V,"♛")):l==="r"?(a(),o("span",D,"♜")):l==="b"?(a(),o("span",E,"♝")):l==="n"?(a(),o("span",K,"♞")):l==="p"?(a(),o("span",L,"♟")):l==="/"||l===" "?(a(),o("span",M)):(a(),o("span",O,u(l),1))],10,S))),128))]))),128))])])}const U=v(B,[["render",H],["__scopeId","data-v-6bc27875"]]),W=f({name:"NQueens",components:{ChessBoard:U},data(){return{size:8,board:null,log:"",scans:null,attempts:[],message:"sdfsdf"}},mounted(){this.solve()},methods:{solve(){this.attempts=[],this.scans=[];var e=()=>{this.tryOneRandomSolution()||setTimeout(e,0)};e()},tryOneRandomSolution(){var e=[],s=[];this.createBoard(),this.log="";let t=1;for(var r=0;r<this.size;r++){let{pos:n,spaces:h}=this.randomWhiteSpace();e.push(n),s.push(h),n?(t&=this.addQueen(n),this.log+="queen: "+n.x+","+n.y+" spaces: "+h+`
`):(r=this.size,t=0)}return this.attempts.push({attempt:e,spaces:s,ok:t}),t},randomWhiteSpace(){for(var e=this.size*this.size,s=[],t=0;t<e;t++){var r=t%this.size,n=Math.floor(t/this.size);this.board[n][r]===" "&&s.push({x:r,y:n})}var h=~~(Math.random()*s.length);return{pos:s[h],spaces:s.length}},addQueen(e){var s=e.x,t=e.y;if(this.board[t][s]==="!")return 0;var r=1;for(let i=0;i<this.size;i++)i!==s&&(r&=this.addThreat(i,t));for(let i=0;i<this.size;i++)i!==t&&(r&=this.addThreat(s,i));for(let i=1;i<this.size;i++){var n=(s+i)%this.size,h=(t+i)%this.size;(n>s&&h>t||n<s&&h<t)&&(r&=this.addThreat(n,h))}for(let i=1;i<this.size;i++){var n=(this.size+s-i)%this.size,h=(t+i)%this.size;(n<s&&h>t||n>s&&h<t)&&(r&=this.addThreat(n,h))}return this.board[t][s]===" "?this.board[t][s]="q":(this.board[t][s]="X",r=0),r},addThreat(e,s){return this.board[s][e]===" "||this.board[s][e]==="/"?(this.board[s][e]="/",1):(this.board[s][e]="X",0)},createBoard(){for(var e=[],s=0;s<this.size;s++){e.push([]);for(var t=0;t<this.size;t++)e[s].push(" ")}this.board=e}}}),X=p("h1",null,"n-Queens",-1),A=p("p",null,"n-Queens is a well known puzzle. This program will solve it but it will get exponentially slower with bigger boards. It works by randomly placing queens in an unprotected space and if there are no more spaces it starts again. Is it possible to write a program that does not slow down exponentially as board size increases?",-1),P=p("label",{for:"input-size"},"Board size",-1),j=p("p",null,"queens placed : unprotected spaces before queens placed",-1);function G(e,s,t,r,n,h){const i=w("chess-board");return a(),o("section",null,[X,c(),A,c(),P,c(),k(p("input",{id:"input-size","onUpdate:modelValue":s[0]||(s[0]=d=>e.size=d),type:"text",placeholder:"4 to 16 are good numbers","aria-label":"Board size",onKeyup:s[1]||(s[1]=z((...d)=>e.solve&&e.solve(...d),["enter"]))},null,544),[[y,e.size]]),c(),p("button",{type:"button",onClick:s[2]||(s[2]=(...d)=>e.solve&&e.solve(...d))},"Solve"),c(),$(i,{board:e.board},null,8,["board"]),c(),p("ul",null,[p("li",null,"attempts: "+u(e.attempts.length),1)]),c(),p("pre",null,u(e.log),1),c(),j,c(),p("ul",null,[(a(!0),o(m,null,b(e.attempts,d=>(a(),o("li",{key:d.$id},u(d.spaces.length+d.ok-1)+`
        :
        `+u(d.spaces),1))),128))])])}const Z=v(W,[["render",G]]);export{Z as default};
